---
title:  "[Python] 기초 문법 살펴보기 (2)"
excerpt: "Python의 자료형 - 튜플, 딕셔너리, 집합"

toc : true
toc_sticky : true

categories:
  - Python
tags: 
  - Python
---


## 3. 튜플 자료형

튜플은 리스트와 거의 비슷한 역할을 하지만 프로그래밍을 할 때 튜플과 리스트는 구별해서 사용하는 것이 좋다.
튜플과 리스트의 가장 큰 차이점은 요소값을 변화시킬 수 있는지의 여부이다. 즉, 리스트는 요소값을 바꿀 수 있지만 튜플은 불가능 하다.

리스트는 []를 사용했지만 튜플은 ()를 사용한다. 대부분의 특징이 리스트와 일치하기 때문에 간단한 특징만 알아보자.

```py
>>> t1 = (1,2,3,4)
>>> del t1[0]
'error' -> 요소 변화가 불가능

>>> t2 = (1,2,3,4)
>>> t1[1] = 3
'error' -> 마찬가지로 요소 변화 불가능
```


<br/><br/>

## 4. 딕셔너리 자료형

딕셔너리는 Key와 Value를 한 쌍으로 가지는 자료형이다. 딕셔너리는 리스트나 튜플처럼 순차적으로 해당 요소값을 구하지 않고 Key를 통해 Value를 얻는다는 것이 가장 큰 특징이다.

### 4.1 딕셔너리의 선언

앞서 말한바와 같이 Key, Value가 한 쌍을 이루고 있으며 Key로는 정수, 문자열을 사용할 수 있고 Value에는 리스트도 사용할 수 있다.

```py
>>> dic1 = {'a':'apple', 'b':'banana', 'c':'carrot'}
>>> dic2 = {1:'one', 2:'two', 3:'three'}
>>> dic3 = {'a':[1,2], 'b':[3,4]}
```

### 4.2 딕셔너리 관련 함수

#### 4.2.1 리스트 만들기 (keys, values, items)

딕셔너리에서 key만 뽑아오거나 value만 뽑아서 리스트를 만들 수 있다. 해당 함수들을 사용하면 dict_ 객체를 리턴한다.

```py
>>> dic = ['SON':'TOT', 'KIM':'BAY', 'LEE':'PAR']
>>> dic.keys()
dict_keys(['SON','KIM','LEE'])

>>> dic.values()
dict_values(['TOT','BAY','PAR'])

>>> dic.items()
dict_items([('SON','TOT'), ('KIM','BAY'), ('LEE','PAR')])
```

#### 4.2.2 모두 지우기 (clear)

```py
>>> dic = [1:"one", 2:"two"]
>>> dic.clear()
{}
```

#### 4.2.3 Key로 Value 얻기 (get)

Key 값을 사용해서 Value를 가져올 수 있다. [key]나 .get(key)을 사용해서 값을 가져올 수 있는데 두 방식에 약간의 차이가 있다.
[key]를 사용해서 value 값을 가져오는데 key 값이 존재하지 않는다면 에러가 발생하지만 .get(key)을 사용해서 value 값을 가져올 때는 key 값이 존재하지 않으면 에러가 아닌 None을 리턴한다는 차이가 있다.<br/>
그래서 .get(key)를 사용한다면 디폴트 값을 지정해 줄 수 있다.

```py
>>> dic = ['SON':'TOT', 'KIM':'BAY', 'LEE':'PAR']
>>> dic.get('SON')
'TOT'

print(dic['HWANG'])
'error'

print(dic.get('HWANG'))
'NONE'

print(dic.get('HWANG', 'WOL'))
'WOL'
```


#### 4.2.4 Key가 딕셔너리에 있는지 조사하기

조사할 Key가 딕셔너리에 있으면 true 없으면 false를 반환한다.

```py
>>> dic = [1:'one', 2:'two']
>>> 1 in a
True

>>> 3 in a
False
```

<br/><br/>


## 5. 집합 자료형

집합 자료형은 집합에 관련된 것을 쉽게 처리하려고 만든 자료형으로 set을 사용해 만들 수 있다.

set의 특징은 중복을 허용하지 않고 순서가 없다는 것이다. 때문에 인덱싱을 통해 요소를 얻을 수 없어서 인덱싱으로 접근하려면 리스트나 튜플로 변환한 후에 해야한다.

### 5.1 집합 자료형의 선언과 변환

set을 사용해 선언할 수 있다. 중복을 허용하지 않기 때문에 'Hello'에서 중복되는 l이 하나만 들어간다.

```py
>>> s1 = set([1,2,3])
>>> s1
{1,2,3}

>>> s2 = set("Hello")
>>> s2
{'e','H','l','o'}
```

리스트는 순서가 없기 때문에 리스트나 튜플로 변환 후 인덱싱을 사용할 수 있다.

```py
>>> s1 = set([1,2,3])
>>> list1 = list(s1)
>>> list1
[1,2,3]

>>> li[0]
1

>>> t1 = tuple(s1)
>>> t1
(1,2,3)

>>> ti[0]
1
```

### 5.2 교집합, 합집합, 차집합 구하기

set을 유용하게 사용하는 경우는 교집합, 합집합, 차집합을 구할 때이다. <br/>
교집합은 &, intersection을 사용하고 합집합은 |, union을 사용하며 차집합은 -, difference를 사용한다.

```py
>>> s1 = set([1,2,3,4,5,6])
>>> s2 = set([4,5,6,7,8,9])

>>> s1 & s2
{4,5,6}
>>> s1.intersection(s2)
{4,5,6}

>>> s1 | s2
{1,2,3,4,5,6,7,8,9}
>>> s1.union(s2)
{1,2,3,4,5,6,7,8,9}

>>> s1 - s2
{1,2,3}
>>> s1.difference(s2)
{1,2,3}
```


### 5.3 값의 추가, 삭제

이미 만들어진 set에 값을 추가하거나 제거할 수 있다. 1개의 값만 추가할 때는 add, 여러 값을 추가할 때는 update, 특정 값을 제거할 때는 remove를 사용한다.

```py
>>> s1 = set([1,2,3])
>>> s1.add(4)
>>> s1
{1,2,3,4}

>>> s2 = set([1,2,3])
>>> s2.update([4,5,6])
>>> s2
{1,2,3,4,5,6}

>>> s3 = set([1,2,3])
>>> s3.remove(2)
>>> s3
{1,3}
```

